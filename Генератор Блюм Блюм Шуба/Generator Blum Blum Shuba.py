import random
from scipy import stats
import numpy as np

# Оптимизированная проверка простоты чисел с использованием теста Миллера-Рабина
def is_prime(n, k=5):  # k - количество раундов теста Миллера-Рабина
    # Проверка на простоту числа n
    if n <= 1:
        return False  # Числа <= 1 не являются простыми
    if n == 2 or n == 3:
        return True  # 2 и 3 - простые числа
    if n % 2 == 0:
        return False  # Четные числа больше 2 не являются простыми

    # Представляем n - 1 как (2^r) * d, где d нечетное
    r, d = 0, n - 1
    while d % 2 == 0:
        r += 1  # Считаем количество раз, которое 2 делит d
        d //= 2  # Делим d на 2, пока это возможно

    # Тест Миллера-Рабина
    for _ in range(k):  # Запускаем тест k раз для повышения надежности
        a = random.randint(2, n - 2)  # Случайное число a в диапазоне [2, n-2]
        x = pow(a, d, n)  # Вычисляем a^d mod n
        if x == 1 or x == n - 1:
            continue  # Условия для прохода теста

        # Проверка x в степени 2, пока не достигнем n-1 или не исчерпаем r
        for i in range(r - 1):
            x = pow(x, 2, n)  # Возводим в квадрат и берем по модулю n
            if x == n - 1:
                break  # Успех, число может быть простым
        else:
            return False  # Если x не оказалось равным n-1, то n не простое
    return True  # Если все тесты пройдены, n - простое


# Генерация простого числа p ≡ 3 (mod 4)
def generate_prime(modulus=4, remainder=3, bits=64):
    # Бесконечный цикл для генерации простого числа
    while True:
        prime = random.getrandbits(bits)  # Генерация случайного числа заданной длины
        if prime % modulus == remainder and is_prime(prime):  # Проверка на соответствие условиям
            return prime  # Возвращаем найденное простое число


# Реализация генератора Blum Blum Shub
def blum_blum_shub(seed, p, q, bit_length=128):
    n = p * q  # Вычисляем произведение p и q
    s = seed % n  # Начальное значение s должно быть меньше n и взаимно простым с n
    result = []  # Список для хранения сгенерированных битов

    for i in range(bit_length):
        s = (s ** 2) % n  # Обновляем s по формуле s_{i+1} = (s_i^2) mod n
        bit = s % 2  # Извлекаем младший бит
        result.append(bit)  # Добавляем бит в результат

    return result  # Возвращаем сгенерированные биты


# Генерация двух больших простых чисел p и q
p = generate_prime()  # Генерация первого простого числа
q = generate_prime()  # Генерация второго простого числа

# Начальное значение seed должно быть взаимно простым с n = p * q
seed = random.randint(2, p * q - 1)  # Генерация случайного значения для seed

# Генерация 128 битов с использованием BBS
bbs_output = blum_blum_shub(seed, p, q, bit_length=128)

# Преобразование последовательности битов в строку
random_bits = ''.join(map(str, bbs_output))  # Преобразуем список битов в строку

# Печать результатов
print(f"Сгенерированные биты: {random_bits}")  # Вывод сгенерированных битов
print(f"Число в десятичной системе: {int(random_bits, 2)}")  # Конвертация битов в десятичное число